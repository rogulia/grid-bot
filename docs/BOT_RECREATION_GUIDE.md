# Руководство по воссозданию бота GRID-Trader с нуля

**Дата создания:** 2025-10-16
**Версия:** 1.0
**Назначение:** Техническое описание работы торгового бота для полного воссоздания

---

## ОБЩЕЕ ОПИСАНИЕ

### Что такое GRID-Trader?

GRID-Trader - это автоматический торговый бот для бессрочных фьючерсов на бирже Bybit. Бот реализует **двустороннюю сеточную стратегию** (одновременно LONG и SHORT позиции) с **усреднением по мартингейлу** и фиксацией прибыли при развороте цены.

### Ключевые характеристики

- **Язык:** Python 3.9+
- **Биржа:** Bybit (Demo и Production)
- **Тип контрактов:** Perpetual Futures (USDT)
- **Режим позиций:** Hedge Mode (позволяет держать одновременно LONG и SHORT)
- **Архитектура:** Multi-account SaaS-ready (поддержка множества изолированных аккаунтов)

### Для кого этот бот?

Бот разработан для SaaS модели, где:
- Каждый аккаунт = один пользователь/клиент, пример конфига - @config/config.yaml (там же указан демо счет или нет - это критически важно так как подписка на вебсокеты или endpoints api могут быть разными для демо и прода)
- Общие константы для работы бота в целом @config/constants.py
- Полная изоляция данных между аккаунтами - падение одного клиента не должно затрагивать остальных клиентов, при этом нужен механизм управляемого отключения клиента в случае сбоев на его стороне - отключить открытые вебсокеты (приватные всегда, публичные только если они не используются другими клиентами)
- Независимые API ключи, риск-лимиты, стратегии
- Общие WebSocket соединения для одинаковых монет у разных пользователей для экономии ресурсов
- У каждого клиента должны быть свои логи в своих папких с id клиента + нужны общие логи работы бота в целом
- Критические (вызывающие падение приложения), ошибочные (неверный код, неверные запросы или неверная форма ответа) и предупреждающие warning (прочие некритические предупреждения) логи должны писаться в отдельный файл, информацияонные (отправки запросов и получение ответов, а также изменение состояния бота или торгового счета) и debug (прочие уведомения не меняющие состояние системы) в другой файл
- пользователей может быть несколько, у каждого пользователя может быть несколько монет, они могут совпадать у разных пользователей, но при этом у каждого пользователя могут быть индивидуальные настройки торговли

---

## ТОРГОВАЯ СТРАТЕГИЯ

### Принцип работы

Бот торгует **ОДНОВРЕМЕННО** на LONG и SHORT с независимым управлением каждой стороной.

#### Начальное состояние

При старте бота:
1. Проверить, что аккаунт готов:
   - проверить какое максимальное плечо доступно на этой паре по REST API
   - установить min(плечо пользователя, максимальное плечо с биржи) плечо по выбранной монете на бирже по REST API
   - проверить что тип маржи аккаунта Cross Margin, если нет - поменять по REST API
2. Если на аккаунте уже есть ордера по выбранной монете - восстановить их в стейт бота (то есть записать состояние биржи в файл, подробнее ниже)
3. Открыть начальную позиция LONG (например, за 1 USD маржи с плечом 75x - конкретные параметры берутся из конфига учитывая минимальный размер позиции по ограничениям биржи), позиция должна открываться лимитным ордером
4. Затем тут же открывается позиция такого же размера в ШОРТ, чтобы qty позиций совпадали - это кричиески важно, позиция должна открываться лимитным ордером
5. Устанавливаются TP (Take Profit) ордера для обеих сторон согласно take_profit_percent из конфига
6. На наждом направлении на 1 уровень против движения цены должен быть заранее выставлен лимитный ордер усреднения на x2 начального объема, если позволяет остаток свободных средства (см об этом ниже)

#### Стейт бота
По каждому аккаунта должен быть создан и поддерживаться в актуальном состоянии на протяжении всей работы стейт бота - это json файл формата:
{
  "DOGEUSDT": {
    "timestamp": "2025-10-16T19:59:54.480795+03:00", - дата последнего обновления стейта
    "long_positions": [
      {
        "quantity": 376.0,
        "entry_price": 0.19933,
        "grid_level": 0,
        "order_id": order ID
        "created": datetime,
        "executed": datetime
      },
      {
        "quantity": 752.0,
        "entry_price": 0.19692,
        "grid_level": 1,
        "order_id": order ID
        "created": datetime,
        "executed": datetime
      },
    ],
    "short_positions": [
      {
        "quantity": 376.0,
        "entry_price": 0.18868,
        "grid_level": 0,
        "order_id": order ID
        "created": datetime,
        "executed": datetime
      },
      {
        "quantity": 376.0,
        "entry_price": 0.18873,
        "grid_level": 1,
        "order_id": order ID
        "created": datetime,
        "executed": datetime
      }
    ],
    "long_tp_order_id": "24e13574-792b-4c8b-9d75-c43438c8a5be",
    "short_tp_order_id": "bac389bd-0648-4664-9d26-4cd744457923"
  }
}

"quantity" - количество монет (на одних и тех же уровнях должно совпадать!)
"entry_price" - цена входа
"grid_level": - уровень в грид-сетке
"order_id": order ID - должен быть всегда
"created": datetime - должен быть всегда
"executed": datetime - только если исполнен

При запуске скрипта бот должен:
 - удалить все невыполненные ордера с биржи (тейки и лимитки устарели, так как неизвестно сколько бот был выключен)
 - очистить файл стейт бота (локальное состояние могло устареть)
 - восстановить ИСПОЛНЕННЫЕ позиции с биржи по REST API в стейт бота (биржа - источник правды)
 - поставить актуальные тейки по описанным ниже правилам и записать их ID в стейт бота
 - поставить актуальные лимитки чтобы сбалансировать qty обоих сторон и записать их в стейт бота

Как восстанавливать ордера? Вот инструкция для лонгов, для шортов аналогичная:
 - через механизм order history, тебе надо получить filled и частично filled ордера по выбранной позиции
 - для восстановления ордеров находим свежий тейк профит по лонгам (у него reduse = true) и все лонги что перед ним - это уже ордера текущей позиции

#### Нерпкосновенный запас денег
Переменная в конфиге balance_buffer_percent говорит о том, какой запас маржи должен быть всегда доступен на счете и ни при каких условиях не может быть истрачен
Например, если мой Margin Balance 1000 usdt, то неприкосновенный запас 15% от Margin Balance это 150 usdt. Если мой Available Balance составляет 500 usdt, то я могу распологаться для торговых операция только 500-150=350 usdt

#### Усреднение (Averaging)

Когда цена движется **ПРОТИВ** позиции на заданный процент (например, 1%, указан в конфиге в grid_step_percent):
- Нужно проверить достаточность баланса:
  - посчитать сколько маржи нужно для усреднения
  - умножить это число на два (чтобы гарантированно хватило бы денег для лимитного ордера на противоположной стороне)
  - проверить что свободного баланса хватает на усреднения в обе стороны + неприкосновенный запас
  - если нет - остановиться и залоггировать это событие с warning, если да - идти дальше:
    - Нужно докупить позицию на x2 объема от предыдущего уровня
    - Тут же у противоположной позиции устанавливить страховочный ордер на такой же объем так же на расстоянии 1% от цены последнего ордера
    - таким образом мы всегда имеем позиции одинакового размера по qty либо в уже исполненных ордерах, либо в отложенных лимитках - это ключевая часть бота - в любой момент времени все позиции должны быть одинаковыми по qty либо в уже исполненных ордерах, либо в лимитных ордерах
    - важно - если маржи не хватает для усреднения И выставления лимитного ордера на противоположной стороне, то усредняться НЕ надо вообще
    - чтобы узнать на каком грид уровне находится в каком направлении находится бот - читай стейт файл
 - важно, что при наличии денег у позиций должен быть открыт лимитный ордер на усреднение с двойным объемом относительно предыдущего ордера и на расстоянии 1% от предыдущего ордера как минимум на 1 уровне от последнего ордера
 - каждое усреднение означает, что состояние ордеров изменилось, а значит надо отменить установленные тейки, пересчитать их и поставить заново по описанным ниже правилам

**Пример для LONG:**
- Уровень 0: цена $1.00, открыли 75 монет (1 USD × 75 плечо / 1.00)
- Цена упала до $0.99 (-1%)
- Уровень 1: должен сработать заранее установленный лимитный ордер на 150 монет (2 USD × 75 плечо / 0.99) + ставим ещё один лимитный ордер на противоположной стороне ШОРТ ещё на 150 монет на расстоянии 1% от последнего уровня (реального или лимитного)
- Цена упала до $0.98 (-1% от $0.99)
- Уровень 2: должен сработать заранее установленный ещё на уровне 1 лимитный ордер на 300 монет (4 USD × 75 плечо / 0.98) + ставим ещё один лимитный ордер на противоположной стороне ШОРТ ещё на 300 монет на расстоянии 1% от последнего уровня (реального или лимитного)
- И так далее до максимального уровня (обычно 10, указано в конфиге в переменной max_grid_levels_per_side)
- ключевой момент, пока хватает денег по КАЖДОМУ направлению должен быть открыт как минимум один лимитный ордер для усреднения цены
- лимитные ордера должны открываться симметрично для лонг и шорт, либо не открываться вообще

#### Источник информации об исполненных ордерах
 - после восстановления стейта бота по REST API, дальнейший источник информации - приватный вебсокет
 - именно вебсокет должен сообщать об установленных лимитных ордерах и тейках и именно после получения информации о нем бот должен обновлять стейт бота (не когда команда на открыти отправлена, а когда вебсокет подтвердил усешное исполнение)
 - именно вебсокет должен сообщать о сработавшем тейке, что должно инициировать отмену всех невыполненных ордеров и их переустановку (смотри процедуру по тейку ниже)
 - любые изменения ордеров (открытие, исполнение, отмена) должны фиксироваться в стейте бота

#### Take Profit (Фиксация прибыли)
 - тейкпрофит всегда должен закрывать всю позицию целиком на уровне фиксации прибыли 1% с учетом комиссии, то есть я должен получить чистый 1% прибыли без учета оплаченных комиссий за открытие ордеров и будущее закрытие. Размер прибыли (например, 1%) указан в конфиге take_profit_percent
 - цена тейкпрофита считается по средневзвешенной цене входа с учетом уже уплаченный комиссий, уже уплаченного фандинга и будующей комиссии на закрытие позиции которую можно заранее расчитать
 - тейкпрофит всегда должен быть выставлен заранее когда сделка обновилась (была выставлена или была усреднена)
 - после исполнения тейк профита необходимо:
   - отменить все лимитные ордера усреднения по этому направлению
   - тут же открыть новую позицию по лимитке на уровне противоположной позиции минус два шага (количество исполненных ордеров по противоположней позиции отражено в стейте бота). Если нужно открыться сразу на несколько уровней, то каждый уровень должен открываться отдельным ордером чтобы сохранить последовательность ордеров

   **Визуальный пример:**
   Противоположная позиция на уровне 8 → открываем текущую на уровне 6

   | Уровень | Количество | Тип ордера | Цель |
   |---------|------------|------------|------|
   | 0 | 1 | Маркет/Лимит | Немедленное исполнение |
   | 1 | 2 | Маркет/Лимит | Немедленное исполнение |
   | 2 | 4 | Маркет/Лимит | Немедленное исполнение |
   | 3 | 8 | Маркет/Лимит | Немедленное исполнение |
   | 4 | 16 | Маркет/Лимит | Немедленное исполнение |
   | 5 | 32 | Маркет/Лимит | Немедленное исполнение |
   | 6 | 64 | Лимитка | На 1% от уровня 5 |
   | 7 | 128 | Лимитка | На 1% от уровня 6 |

   Итого открыто: 1+2+4+8+16+32 = 63 монет (уровни 0-5), + 2 страховочные лимитки (уровни 6-7)

   - на недостающие 2 уровня надо открыть лимитки с удвоением объема на каждом шагу на расстоянии 1% сохраняя сетку
   - таким образом мы всегда должны сохранять основной принцип безопасной торговли - в любой момент времени qty противоположных направлений всегда равны либо по уже исполненным ордерам, либо по ещё не исполненным, но установленным ордерам

**Пример продолжения для LONG:**
- Средневзвешенная цена входа: $0.99 (с учетом всех усреднений)
- Цена выросла до $1.00 (+1.01% от $0.99)
- Закрываются все LONG позиции по заранее установленному тейку (75 + 150 + 300 = 525 монет)
- Прибыль зафиксирована
- закрыть все оставшиеся нереализованные лимитки по этой стороне
- перевыставить позицию на минус два шага от противоположной стороны отдельными ордерами
- на оставшиеся два шага поставить лимитки на расстоянии 1% согласно сетке
- не забудь все отмены и новые ордера отразить в стейте когда они появятся в приватном вебсокете
- Цель: всегда держать обе стороны открытыми (хедж)

### Формула мартингейла

**ВАЖНО:** Используется классическая формула мартингейла:

```
margin_new = margin_previous × multiplier
```

Не путать с неправильной формулой где первые два уровня одинаковые.

**Правильно:** 1 → 2 → 4 → 8 → 16...
**Неправильно:** 1 → 1 → 2 → 4 → 8...

### Идеальная симметрия количеств (Reference Qty)

Бот использует систему **референсных количеств** для идеального хеджа:

1. Когда первая сторона открывает уровень 1 → сохраняется количество монет как эталон
2. Когда вторая сторона открывает уровень 1 → используется ТО ЖЕ количество
3. Когда открываются следующий уровень по каждой из сторон - они умножают предыдущий уровень монет на 2 (averaging_multiplier в конфиге)

**Зачем?** Из-за разницы цен количество монет может отличаться:
- LONG @ $0.21: 357 монет
- SHORT @ $0.20: 375 монет (без reference qty)

С reference qty:
- LONG @ $0.21: 357 монет
- SHORT @ $0.20: 357 монет (используется сохраненное значение)

**ВАЖНО**
Всегда (!) подумай дважды какие расчеты выполнять с учетом плеча, а какие нет!

**Результат:** Идеальный хедж - движение цены одинаково влияет на обе стороны.

---

## АРХИТЕКТУРА СИСТЕМЫ

**Важно:** HTTP используется только для команд и синхронизации. Реальные данные идут через WebSocket. Стейт бота в любой момент времени должен отражать реальное состояние дел на бирже

### Мульти-аккаунт архитектура

#### Изоляция данных

Каждый аккаунт имеет:
- **Свои API ключи:** `{ID}_BYBIT_API_KEY`, `{ID}_BYBIT_API_SECRET`
- **Свой BybitClient:** Независимый HTTP клиент
- **Свои стратегии:** Может торговать разные символы
- **Свои риск-лимиты:** Например, аккаунт 1 = 90% MM Rate, аккаунт 2 = 50%
- **Свои файлы данных:** `001/bot_state.json`, `001/trades_history.csv`
- **Свои логи:** `001/bot_YYYY-MM-DD.log`, `001/trades_YYYY-MM-DD.log`, `001/positions_YYYY-MM-DD.log`
- **Свой emergency stop:** `001/.emergency_stop`

**Формат ID:** 001, 002, 003... (zero-padded для сортировки)

#### Шаринг WebSocket

Чтобы не создавать 100 WebSocket соединений для 50 аккаунтов, торгующих одни символы:

**Ключ шаринга:** `(symbol, demo: bool)`

**Примеры:**
- 3 аккаунта торгуют SOLUSDT в demo → 1 WebSocket
- 1 аккаунт SOLUSDT demo + 1 аккаунт SOLUSDT prod → 2 WebSocket
- Аккаунт1: SOL+DOGE (demo), Аккаунт2: SOL (prod) → 3 WebSocket

**Как работает:**
1. `MultiAccountBot` регистрирует аккаунт
2. Для каждого символа проверяет: есть ли уже WebSocket для `(symbol, demo)`?
3. Если да → подписывает аккаунт на существующий WebSocket
4. Если нет → создает новый WebSocket
5. При получении цены → рассылает всем подписанным аккаунтам

---

## КЛЮЧЕВЫЕ WORKFLOW

### Workflow 1: Запуск и инициализация

**Шаги:**

1. **Загрузка конфигурации**
   - Читается `config/config.yaml`
   - Для каждого аккаунта проверяется наличие API ключей в `.env`
   - Валидируется конфигурация (плечо, размеры, проценты)

2. **Проверка emergency stop файлов**
   - Для каждого аккаунта проверяется наличие `.{ID}_emergency_stop`
   - Если файл есть → бот останавливает любые операции для этого аккаунта, но продолжает выполнять другие
   - Пользователь должен удалить файл вручную после исправления проблемы

3. **Инициализация аккаунтов (по одному)**
   - Устанавливается режим позиций: Hedge Mode (mode=3)
   - Устанавливается плечо для каждого символа
   - Получается баланс аккаунта через REST API (ОБЯЗАТЕЛЬНО!)
   - если на бирже уже есть какие-то позиции:
     - заполняется стейт бота
     - удяляются все неисполненные тейки и лимитки (так как мы не знаем как долго бот был в отключке)
     - восстанавливаются теки и лимитки по заранее описанным выше правилам

4. **Запуск WebSocket соединений**
   - Создается `BybitPrivateWebSocket` для execution стрима (ОДИН на аккаунт)
   - Для каждого символа создается `BybitWebSocket` с:
     - Position callback
     - Wallet callback
     - Order callback
   - WebSocket подключаются и подписываются на стримы

5. **Восстановление состояния (критически важно!)**
   - **ДО** запуска WebSocket стримов данных
   - удаляются все неисполненные ордера (лимитки и тейки)
   - Выполняется синхронизация с биржой
   - **Обработка конфликтов во время синхронизации:**
     1. Если во время синхронизации пришло обновление по вебсокету (позиция изменилась/отменилась)
     2. → Прервать текущую синхронизацию
     3. → Очистить стейт бота
     4. → Начать синхронизацию заново
     5. → Цель: гарантировать актуальность стейта на момент запуска вебсокета
   - затем должы запускаться стандартные процедуры по расстановке лимиток с занесением информации в стейт бота + расстановка тейков с занесением информации в стейт бота

6. **Начало работы**
   - Бот входит в основной цикл
   - Каждую секунду проверяется shutdown флаг

7. **Проверка Take Profit**
   - Для LONG: рассчитать средневзвешенную цену входа
   - Если текущая цена выше на tp_percent → закрыть ВСЕ LONG
   - Аналогично для SHORT (цена ниже на tp_percent)
   - После закрытия → переоткрытие (см. Workflow 5)

8. **Периодическая синхронизация** (каждые 60 секунд)
   - Вызвать `sync_with_exchange()` для проверки соответствия с биржей
   - Залогировать текущее состояние
   - Сохранить снапшот в metrics_tracker

9. **Размещение ордера**
   - Определить `positionIdx`: 1 для LONG (Buy), 2 для SHORT (Sell)
   - Получить orderId из вебсокета при установке ордера, а дату исполнения при получении сообщения об исполнении

### Workflow 2: Переоткрытие после закрытия

**Триггер:** Одна сторона закрылась по тейку

**Логика переоткрытия:**

Если закрылся LONG → открыть LONG
Если закрылся SHORT → открыть SHORT

**Зачем:** Поддерживать двусторонний хедж постоянно

**Шаги:**

1. **Определить сторону для переоткрытия**
   - закрывшеаяся

2. **Размещение ордера**
   - Определить positionIdx
   - Разместить лимитные ордера на уровне текущей цены на уровне шага противоположней позиции минус два
   - Каждый шаг должен открываться отдельным ордером чтобы можно было восстановить последовательность ордеров
   - на оставшиеся два шага поставить лимитки, каждая на 1% от предыдущего ордера
   - все исполненные ордера фиксировать в стейте бота

3. **Создание TP ордера**
   - Рассчитать TP цену для начальной позиции
   - Разместить лимитный ордер
   - Сохранить TP order ID

### Workflow 6: Восстановление состояния после рестарта

**Когда:** Бот запустился после остановки/краша

**Проблема:** Локальное состояние (в памяти) потеряно, бот стейт есть, но мы не знаем актуален ли он, источник правды - позиции на бирже остались

**Решение:** Синхронизация с биржей (REST API) и запись в state file

**Процесс:**

#### Шаг 1: Загрузка state file

- Читается JSON файл `{ID}/bot_state.json` и очищается
- на бирже удаляются все неисполненные ордера включая будущие лимитки и тейки
- Восстанавливаются выполненные позиции установленные на бирже (entry_price, quantity, grid_level и тд)
- Устанавливаются тейки по правилам и сохраняется в стейте их order IDs
- Устанавливаются лимитки чтобы выровнять qty разных позиций + по возможности ставится плюс один тейк на каждую сторону для ближайших усреднений, но так, чтобы установленные уровни по обоим стороным ВСЕГДА совпадали + всё сохраняется в стейте

**Важно:** State file может быть:
- Пустой (первый запуск)
- Устаревший (что-то изменилось на бирже пока бот был выключен), а значит его нужно очистить и восстановить выполенными ордерами с биржи + новыми лимитными страховочными ордерами и тейками
- Корректный

---

## WEBSOCKET АРХИТЕКТУРА

### Типы WebSocket соединений

Бот использует **гибридную архитектуру**: REST API для команд, WebSocket для данных.

#### 1. Публичный WebSocket (цены)

**Endpoint:** `wss://stream.bybit.com/v5/public/linear`

**Топик:** `tickers.{symbol}`

**Что передает:**
- `lastPrice` - текущая цена
- `bid1Price`, `ask1Price` - лучший bid/ask
- `volume24h` - объем за 24 часа
- Другие market data поля

**Использование:**
- НЕ требует аутентификации

**Шаринг:** Один WebSocket на (symbol, environment) пару, рассылается всем аккаунтам

#### 2. Приватный WebSocket #1: Position/Wallet/Order (per symbol)

**Endpoint:** `wss://stream-demo.bybit.com/v5/private` (demo)
**Endpoint:** `wss://stream.bybit.com/v5/private` (prod)

**Топики:**
- `position.linear.{symbol}` - изменения позиции
- `wallet` - баланс и MM Rate
- `order.linear.{symbol}` - обновления ордеров

**Требует:** API key + secret для аутентификации

**Position события:**

Приходит когда:
- Позиция открылась
- Позиция закрылась (size=0)
- Позиция изменилась (усреднение)

Поля:
- `side` - 'Buy' или 'Sell'
- `size` - текущий размер
- `avgPrice` - средняя цена
- `cumRealisedPnl` - накопленный реализованный PnL
- `liqPrice` - цена ликвидации

**Использование:**
- Детектирование закрытий позиций
- Обновление liquidation price
- НЕ используется для restoration (ненадежный snapshot)

**Wallet события:**

Приходит когда баланс изменился:

Поля:
- `accountType` - 'UNIFIED'
- `totalAvailableBalance` - доступный баланс
- `accountMMRate` - Account Maintenance Margin Rate
- `totalInitialMargin` - используемая IM
- `totalMaintenanceMargin` - используемая MM

**Использование:**
- Обновление кеша в balance_manager
- Мониторинг MM Rate для emergency close
- Расчет доступных средств

**Order события:**

Приходит при изменении статуса ордера:

Поля:
- `orderId` - ID ордера
- `orderStatus` - 'New', 'PartiallyFilled', 'Filled', 'Cancelled'
- `orderType` - 'Market' или 'Limit'
- `reduceOnly` - true для TP ордеров
- `side`, `qty`, `price`

#### 3. Приватный WebSocket #2: Execution (all symbols)

**Endpoint:** `wss://stream-demo.bybit.com/v5/private` demo
**Endpoint:** `wss://stream.bybit.com/v5/private` prod

**Топик:** `execution` (БЕЗ фильтра по символу - все символы аккаунта!)

**Требует:** API key + secret

**Execution события:**

Приходит при каждом исполнении ордера (частичном или полном):

Ключевые поля:
- `symbol` - символ
- `side` - 'Buy' или 'Sell'
- `execPrice` - цена исполнения
- `execQty` - количество
- `execTime` - timestamp (ms)
- `closedSize` - сколько позиции закрылось (> 0 означает CLOSE)
- `execPnl` - РЕАЛЬНЫЙ PnL при закрытии (НЕ оценочный!)
- `execFee` - комиссия

**Использование:**
- **Основной механизм** детектирования закрытий по TP
- Получение точного PnL (не расчетного!)
- Логирование каждой сделки
- Отличие TP от manual close (по PnL знаку)

### Обработка WebSocket событий (threading)

**Важно:** WebSocket callbacks выполняются в **отдельных потоках** (pybit использует threading)

**Проблемы:**
- Race conditions при доступе к shared state
- Необходимость локов
- Callback может вызваться во время restoration

### Reconnect механизм

**Проблема:** WebSocket может отключиться (сеть, Bybit maintenance, etc.)

**Решение:** Автоматический переподключение с exponential backoff

**Логика:**

1. **Heartbeat monitoring**
   - Отдельный поток проверяет `_last_message_time`
   - Если нет сообщений >30 секунд → триггер reconnect
   - Проверка каждые 5 секунд

2. **Exponential backoff**
   - Попытка 1: через 1 сек
   - Попытка 2: через 2 сек
   - Попытка 3: через 4 сек
   - ...
   - Максимум: 60 сек между попытками

3. **Max attempts**
   - Публичный WebSocket: до 10 попыток
   - Приватный WebSocket: до 3 попыток
   - После исчерпания → emergency stop (для приватного)

4. **Cleanup before reconnect**
   - Закрыть старый WebSocket (`ws.close()`, `ws.exit()`)
   - Предотвращает event loop leak
   - Создать новый WebSocket
   - Переподписаться на топики

**Emergency для приватного WS:**

Если Execution WebSocket отключился и не переподключился:
- Аккаунта переводятся в emergency stop
- Создается emergency файл
- событие логгируется
- Без execution стрима бот не может безопасно торговать

---

## УПРАВЛЕНИЕ РИСКАМИ

### MM Rate Monitoring (основной механизм)

**Account Maintenance Margin Rate** - это процент от баланса, используемый как MM.

**Формула (упрощенно):**
MM Rate не надо расчитывать, его значение приходит по вебсокету

**Риск:**
- MM Rate близок к 100% → ликвидация близка
- При MM Rate = 100% происходит ликвидация

**Защита:**
- Настраиваемый порог (по умолчанию 90%)
- Проверяется на КАЖДОМ обновлении цены
- Если MM Rate >= порога → EMERGENCY STOP

**Emergency STOP процесс:**

1. Логируется CRITICAL ошибка с деталями
2. Создается emergency stop файл `{ID}/.emergency_stop` с:
   - Timestamp
   - Symbol
   - Причина (MM Rate exceeded)
   - MM Rate значение
3. Устанавливается `emergency_stopped = True`
4. Все последующие price updates игнорируются

**Почему MM Rate, а не liqPrice?**

В Hedge Mode (LONG + SHORT одновременно):
- `liqPrice` отдельной позиции бессмысленна
- Ликвидация зависит от всего портфеля
- MM Rate учитывает весь аккаунт (все символы, обе стороны)
- Это ЕДИНСТВЕННЫЙ надежный индикатор риска

---

## КРИТИЧЕСКИЕ ПОДВОДНЫЕ КАМНИ

### 1. Hedge Mode Особенности

**positionIdx значения:**
- 0 = One-Way Mode (одна позиция)
- 1 = LONG в Hedge Mode
- 2 = SHORT в Hedge Mode
- 3 = режим "Both Sides" (настройка аккаунта)

**ВАЖНО:** При размещении ордеров ВСЕГДА указывать `positionIdx`!

Неправильно:
```
place_order(side='Buy', qty=100)  # positionIdx не указан
```

Правильно:
```
place_order(side='Buy', qty=100, positionIdx=1)  # Hedge LONG
place_order(side='Sell', qty=100, positionIdx=2)  # Hedge SHORT
```

### 2. ReduceOnly Флаг

**Что это:** Флаг ордера, означающий "только уменьшать позицию"

**Когда обязателен:**
- TP ордера

**Что произойдет без reduceOnly:**
- Ордер может открыть позицию в противоположную сторону

**Правильное использование:**
```
# TP ордер - ОБЯЗАТЕЛЬНО reduceOnly=True
place_order(
    side='Sell',  # Закрыть LONG
    orderType='Limit',
    price=tp_price,
    qty=total_qty,
    positionIdx=1,
    reduceOnly=True  # <-- КРИТИЧНО!
)
```

### 3. Execution vs Position WebSocket

**Execution WebSocket:**
- Сообщает о каждой сделке
- Имеет `closedSize` и `execPnl` - реальные значения
- НАДЕЖНЫЙ источник для детектирования закрытий
- Не имеет snapshot (только updates)

**Position WebSocket:**
- Сообщает об изменениях позиции
- Имеет snapshot (при подключении)
- **НЕ НАДЕЖЕН для restoration!** (Snapshot может быть неполным) - восстанавливаться при запуске ТОЛЬКО по REST API
- Используется только для real-time мониторинга

**Правило:** Restoration только через REST API `get_active_position()` + Order History

### 4. WebSocket Threading

**Факт:** pybit выполняет callbacks в отдельных потоках

**Последствия:**
- Два события могут обрабатываться одновременно
- Shared state требует locks
- Deadlock риски при неправильных locks

**Правила безопасности:**
- Всегда использовать locks для shared data
- Держать lock минимальное время (не делать I/O внутри)
- Избегать вложенных locks (deadlock риск)
- Копировать данные внутри lock, обрабатывать вне lock

### 5. Bybit API Quirks

**Ошибка 110025:** "Position mode not modified"
- Не ошибка! Режим уже установлен
- Обрабатывать как успех

**Ошибка 110043:** "Leverage not modified"
- Не ошибка! Плечо уже такое
- Обрабатывать как успех

**Таймауты:**
- Устанавливать timeout для всех HTTP запросов (рекомендуется 10 сек)
- Без timeout поток может зависнуть навсегда

**Precision:**
- Quantity должно быть кратно `qtyStep`
- Округление через math.floor, не round!
- Проверять minOrderQty и maxOrderQty

### 6. Cross vs Isolated Margin

**Текущая реализация:** Cross Margin

**Что это значит:**
- Весь баланс аккаунта используется как залог
- Ликвидация одного символа может затронуть другие
- MM Rate считается для всего аккаунта

**ВАЖНО:** Бот разработан для Cross Margin, не менять на Isolated!

### 7. State File Corruption

**Причины:**
- Процесс убит (kill -9) во время записи
- Диск заполнен
- Ошибка сериализации JSON

**Симптомы:**
- Файл пустой
- Файл не валидный JSON
- Файл обрезан (partial write)

**Защита:**
- Atomic writes (temp + rename)
- Try-catch вокруг JSON.parse
- Fallback на пустой state если corrupted
- попытка восстановления снова

### 9. Emergency Stop Recovery

**Что делать при emergency stop:**

НИЧЕГО! Из emergency stop администратор выходит руками проанилизировав причину и исправив её, эта ситуация требует ручного вмешательства

**Никогда не удалять emergency файл автоматически!**

### 10. Multi-Symbol Balance Sharing

**Факт:** Все символы одного аккаунта делят один `totalAvailableBalance`

**Последствия:**
- Усреднение на символе A забирает средства для символа B

**Проверка:**
- Перед каждым усреднением проверять reserve
- Симулировать: что если это усреднение пройдет, хватит ли нам сбалансировать противоположную сторону?
- Если нет → блокировать
- все стороны всех символов должны быть сбалансированы и меть одинаковый qty либо по уже исполненным ордерам, либо по установленным лимиткам

### 11. Reference Qty System

**Зачем:** Идеальная симметрия количеств для хеджа

**Как работает:**
1. LONG открывает уровень 2 → qty = 300 монет
3. SHORT открывает уровень 2 → использует 300 (не пересчитывает!)
4. Результат: LONG и SHORT имеют по 300 монет на уровне 2

### 12. Pending Orders Logic

**Зачем:** Ускорить исполнение усреднений

**Как работает:**
1. При открытии уровня N сразу размещается limit ордер на уровень N+1
2. Когда цена доходит → pending автоматически исполняется (быстрее чем market)
3. WebSocket уведомляет → обновляем локальное состояние

---

## РЕКОМЕНДАЦИИ ДЛЯ ВОССОЗДАНИЯ

### 1. Логирование

**Три уровня логов:**

1. **Bot log:** Все события и решения
2. **Trades log:** Каждая сделка
3. **Positions log:** Изменения позиций

**Что логировать:**
- Каждое решение (почему усреднили/не усреднили)
- Все API вызовы (request + response)
- Все WebSocket события
- Все ошибки с полным stack trace
- Все проверки балансов/рисков

**Уровни:**
- DEBUG: прочие уведомения не меняющие состояние системы
- INFO: Важные события (отправки запросов и получение ответов, а также изменение состояния бота или торгового счета)
- WARNING: Подозрительные ситуации и прочие некритические предупреждения
- ERROR: Ошибки, требующие внимания (неверный код, неверные запросы или неверная форма ответа)
- CRITICAL: Аварийные ситуации вызывающие падение приложения

### 2. Risk Management принципы

**Правила:**

1. **Fail-Fast:** Лучше остановиться чем работать с неправильными данными
2. **No Fallbacks:** Никаких дефолтных значений для критических данных
3. **Verify Everything:** Проверять каждый ответ от API

### 3. Обработка ошибок

**Стратегии по типу ошибки:**

**Network errors:**
- Retry with exponential backoff
- Max 3 попытки
- Fallback на emergency stop если критично

**API errors:**
- Логировать полный response
- Проверять retCode
- Не игнорировать "мягкие" ошибки (110025, 110043)

**Data errors:**
- Валидировать все поля
- Проверять типы и ranges
- Fail-fast на неожиданные значения

**Logic errors:**
- Assertions для инвариантов
- Например: `assert long_qty >= 0`
- Exception с детальным сообщением

### 4. Производительность

**Оптимизации:**

1. **WebSocket кеширование:**
   - Balance cache 5 сек TTL
   - Wallet data cache (от WebSocket)
   - Избегать REST API в hot path

2. **Threading:**
   - Минимизировать время в locks
   - Копировать данные, обрабатывать вне lock
   - Избегать I/O внутри locks

3. **Database vs Files:**
   - State file достаточно для small-scale

### 5. Документация кода

**Что документировать:**

1. **Каждый метод:**
   - Что делает
   - Параметры (типы, значения)
   - Возвращаемое значение
   - Exceptions которые может raise
   - Side effects (изменяет ли state?)

2. **Сложная логика:**
   - Inline комментарии
   - Примеры
   - Ссылки на внешние источники (Bybit docs)

### 6. Конфигурация

**Принципы:**

1. **Разделение concerns:**
   - Trading config (leverage, grid steps)
   - Risk config (MM rate, limits)
   - System config (logs, API endpoints)

2. **Validation:**
   - Проверять ВСЕ параметры при старте
   - Fail-fast на invalid config
   - Понятные error messages

3. **Defaults:**
   - Разумные defaults для non-critical
   - NO defaults для critical (symbol, API keys)

4. **Environment:**
   - Secrets в .env (не в config.yaml!)
   - Different configs для demo/prod

### 7. Безопасность

**Важные моменты:**

1. **API Keys:**
   - Никогда не коммитить в git
   - Использовать .env файл

2. **Logs:**
   - Не логировать API secrets
   - Маскировать sensitive data
   - Rotation логов (не заполнять диск)

3. **Files:**
   - Правильные permissions (0600 для state files)
   - Не оставлять temp files
   - Cleanup on shutdown

---

## СПРАВОЧНАЯ ИНФОРМАЦИЯ

### Таблица параметров конфигурации

| Параметр | Тип | Диапазон | Описание | Пример |
|----------|-----|----------|----------|--------|
| **symbol** | string | - | Торговая пара (ОБЯЗАТЕЛЬНО!) | "DOGEUSDT" |
| **leverage** | integer | 1-200 | Торговое плечо (ВЫСОКИЙ РИСК при 75-100x) | 75 |
| **initial_position_size_usd** | float | 0.1-100000 | Начальная маржа в USD | 1.0 |
| **grid_step_percent** | float | 0.01-100 | Шаг сетки в % для усреднения | 1.0 |
| **averaging_multiplier** | float | >1.0-10.0 | Множитель мартингейла | 2.0 |
| **take_profit_percent** | float | 0.01-100 | % прибыли для закрытия | 1.0 |
| **max_grid_levels_per_side** | integer | 1-50 | Максимум уровней усреднения | 10 |
| **mm_rate_threshold** | float | 0-100 | Порог MM Rate для emergency stop | 90.0 |
| **balance_buffer_percent** | float | 0-100 | Неприкосновенный запас баланса | 15.0 |
| **demo_trading** | boolean | true/false | Демо (true) или Продакшн (false) | true |
| **dry_run** | boolean | true/false | Симуляция (true) или Реальная торговля (false) | false |

### Чеклист проверки реализации

#### Инициализация и настройка
- [ ] Hedge Mode установлен корректно (mode=3)
- [ ] Плечо установлено правильно (min из конфига и лимита биржи)
- [ ] Cross Margin режим активирован
- [ ] API ключи загружены из `.env` с правильными ID префиксами
- [ ] Конфигурация валидируется при старте (все параметры в допустимых диапазонах)

#### Управление позициями
- [ ] Начальные LONG и SHORT позиции открываются одновременно
- [ ] Количество монет (qty) одинаковое на обеих сторонах на каждом уровне
- [ ] Reference Qty система работает (одинаковые qty несмотря на разницу цен)
- [ ] Усреднение работает по классической мартингейл формуле: 1→2→4→8→16
- [ ] Лимитные ордера устанавливаются на +1 уровень заранее (когда хватает баланса)
- [ ] Take Profit рассчитывается с учетом комиссий и фандинга

#### WebSocket и синхронизация
- [ ] Execution WebSocket детектирует закрытия по TP корректно
- [ ] Position WebSocket НЕ используется для restoration (только REST API!)
- [ ] Wallet WebSocket обновляет MM Rate в реальном времени
- [ ] Order WebSocket отслеживает статусы TP ордеров
- [ ] Reconnect механизм работает с exponential backoff
- [ ] WebSocket sharing работает корректно по (symbol, demo) ключу

#### Восстановление состояния
- [ ] При запуске удаляются все устаревшие ордера (тейки и лимитки)
- [ ] Стейт бот очищается перед восстановлением
- [ ] ИСПОЛНЕННЫЕ позиции восстанавливаются с биржи по REST API
- [ ] Актуальные TP ордера устанавливаются заново
- [ ] Актуальные лимитки устанавливаются для балансировки qty
- [ ] Конфликты во время синхронизации обрабатываются (повтор синхронизации)

#### Риск-менеджмент
- [ ] MM Rate проверяется на каждом обновлении цены
- [ ] Emergency stop срабатывает при MM Rate >= порога
- [ ] Emergency stop файл создается с timestamp и причиной
- [ ] Неприкосновенный запас (balance_buffer) учитывается при усреднении
- [ ] Проверка баланса перед усреднением: хватит ли на обе стороны + буфер
- [ ] Fail-fast принцип: бот останавливается при невозможности получить критические данные

#### Файлы и логи
- [ ] Стейт бот сохраняется в `{ID}/bot_state.json` с правильной структурой
- [ ] Логи разделены: bot, trades, positions для каждого аккаунта
- [ ] Критические/ERROR логи в отдельный файл
- [ ] INFO/DEBUG логи в другой файл
- [ ] Emergency stop файл: `{ID}/.emergency_stop` (скрытый)
- [ ] Все файлы с ID префиксом: `001/filename` (не `filename_001`)

#### Мульти-аккаунт
- [ ] Каждый аккаунт имеет изолированные API ключи
- [ ] WebSocket sharing работает для одинаковых (symbol, demo) пар
- [ ] Падение одного аккаунта не влияет на другие
- [ ] Аккаунты с разными символами работают независимо
- [ ] Emergency stop одного аккаунта не блокирует остальные

#### Тестирование
- [ ] Все юнит-тесты проходят успешно
- [ ] Dry run режим работает корректно (логи без API вызовов)
- [ ] Demo trading протестирован минимум 1 неделю
- [ ] Восстановление после рестарта работает корректно
- [ ] Переоткрытие после TP работает правильно (уровень -2 от противоположной стороны)
- [ ] Emergency stop тестирован (создание и проверка файла)

---

## ЗАКЛЮЧЕНИЕ

Воссоздание этого бота с нуля - сложная задача, требующая:

1. **Глубокого понимания Bybit API** (Hedge Mode, WebSocket streams, positionIdx)
2. **Знания threading** (race conditions, locks, deadlocks)
3. **Опыта с WebSocket** (reconnects, heartbeat, callbacks)
4. **Риск-менеджмента** (MM Rate, liquidation, balance checks)
5. **Тестирования** (unit, integration, stress tests)

**Ключевые takeaways:**

- **Fail-Fast всегда:** Лучше остановиться чем продолжать с плохими данными
- **WebSocket + REST гибрид:** REST для команд и sync, WebSocket для real-time data
- **MM Rate - единственная правда:** Для Hedge Mode это единственный надежный индикатор риска
- **Restoration критична:** Бот должен корректно восстанавливаться после любого рестарта
- **Threading опасен:** Все shared state требует locks, иначе race conditions

**Что НЕ делать:**

- ❌ Полагаться на liqPrice отдельных позиций в Hedge Mode
- ❌ Использовать Position WebSocket для restoration
- ❌ Игнорировать race conditions ("пока не случилось")
- ❌ Запускать в production без недель тестирования в demo
- ❌ Использовать высокое плечо без понимания рисков

**Следующие шаги:**

1. Прочитать Bybit API документацию полностью
2. Покрыть unit тестами (минимум 100 тестов)
3. Тестировать в demo месяц